{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"BOSWatch 3 Es wird darauf hingewiesen, dass f\u00fcr die Teilnahme am BOS-Funk nur nach den Technischen Richtlinien der BOS zugelassene Funkanlagen verwendet werden d\u00fcrfen. Der BOS-Funk ist ein nicht\u00f6ffentlicher mobiler Landfunk. Privatpersonen geh\u00f6ren nicht zum Kreis der berechtigten Funkteilnehmer. (Quelle: TR-BOS) The intercept of the German BOS radio is strictly prohibited and will be prosecuted. The use is only permitted for authorized personnel. Falls du uns unterst\u00fctzen m\u00f6chtest w\u00fcrden wir uns \u00fcber eine Spende freuen. Server, Hosting, Domain sowie Kaffee kosten leider Geld ;-)","title":"<center>BOSWatch 3</center>"},{"location":"index.html#boswatch-3","text":"Es wird darauf hingewiesen, dass f\u00fcr die Teilnahme am BOS-Funk nur nach den Technischen Richtlinien der BOS zugelassene Funkanlagen verwendet werden d\u00fcrfen. Der BOS-Funk ist ein nicht\u00f6ffentlicher mobiler Landfunk. Privatpersonen geh\u00f6ren nicht zum Kreis der berechtigten Funkteilnehmer. (Quelle: TR-BOS) The intercept of the German BOS radio is strictly prohibited and will be prosecuted. The use is only permitted for authorized personnel. Falls du uns unterst\u00fctzen m\u00f6chtest w\u00fcrden wir uns \u00fcber eine Spende freuen. Server, Hosting, Domain sowie Kaffee kosten leider Geld ;-)","title":"BOSWatch 3"},{"location":"changelog.html","text":"Changelog Version [2.9.0] - date Functions implemented in initial version: Multithreaded Server/Client infrastructure for alarm handling Client can auto fetch connection information over bradocast from server Easy configuration with YAML file for all components Simple module and plugin system to extend functionality Alarmpacket routing system for flexible chains of modules nd plugins Modules Mode filter to filter at specific packet types such as FMS, POCSAG, ZVEI or MSG packets Filter Zum schreiben des Changelog's siehe: http://keepachangelog.com/de/1.0.0/","title":"Changelog"},{"location":"changelog.html#changelog","text":"","title":"Changelog"},{"location":"changelog.html#version-290-date","text":"Functions implemented in initial version: Multithreaded Server/Client infrastructure for alarm handling Client can auto fetch connection information over bradocast from server Easy configuration with YAML file for all components Simple module and plugin system to extend functionality Alarmpacket routing system for flexible chains of modules nd plugins","title":"Version [2.9.0] - date"},{"location":"changelog.html#modules","text":"Mode filter to filter at specific packet types such as FMS, POCSAG, ZVEI or MSG packets","title":"Modules"},{"location":"changelog.html#filter","text":"Zum schreiben des Changelog's siehe: http://keepachangelog.com/de/1.0.0/","title":"Filter"},{"location":"config.html","text":"Konfiguration Die Konfiguration von BOSWatch 3 ist im YAML Format abgelegt und wird nachfolgend beschrieben. Immer wenn f\u00fcr eine Einstellung ein Default Wert angegeben ist, muss diese Einstellung nicht zwingend in die Konfiguration eingetragen werden. Client client: Feld Beschreibung Default name Name zur Identifizierung der Client Instanz inputSource Art der zu nutzenden Input Quelle ( sdr , lineIn oder PulseAudio ) useBroadcast Verbindungsdaten per Broadcast beziehen no reconnectDelay Verz\u00f6gerung f\u00fcr erneuten Verbindungsversuch zum Server 3 sendTries Anzahl der Sendeversuche eines Pakets 3 sendDelay Verz\u00f6gerung f\u00fcr einen erneuten Sendeversuch 3 server: Der Abschnitt server: wird nur genutzt, wenn useBroadcast: no gesetzt ist. Ansonsten wird versucht die Verbindungsdaten per Broadcast Paket direkt vom Server zu beziehen. Feld Beschreibung Default ip IP Adresse des Servers 127.0.0.1 port Port des Sever 8080 Beispiel: server: ip: 10.10.10.2 port: 9123 inputSource: Es gibt die Auswahl zwischen sdr , lineIn oder PulseAudio als Input Quelle. Mit sdr wird direkt per rtl_sdr die zu empfangende Frequenz an Multimon-NG weitergereicht. Mit lineIn wird eine Quelle die (per ALSA ) direkt an die Soundkarte angeschlossen ist an Multimon-NG weitergereicht. Mit PulseAudio wird ein PulseAudio-Sink an Multimon-NG weitergereicht, z.B. in Kombination mit RTLSDR-Airband und/oder Docker. sdr: Feld Beschreibung Default device rtl_fm Device ID 0 frequency Zu empfangende Frequenz error Frequenz Abweichung in ppm 0 squelch Einstellung der Rauschsperre 1 gain Verst\u00e4rkung des Eingangssignals 100 fir_size niedrig leckagearmen Filter None rtlPath Pfad zur rtl_fm Binary rtl_fm Beispiel: inputSource: sdr: device: 0 frequency: 85M error: 0 squelch: 1 gain: 100 rtlPath: /usr/bin/rtl-fm lineIn: Feld Beschreibung Default device die device Id der Soundkarte 1 Device herausfinden Durch eingabe des Befehls aplay -l werden alle Soundkarten ausgegeben. Das schaut ungef\u00e4hr so aus: **** List of PLAYBACK Hardware Devices **** card 0: ALSA [bcm2835 ALSA], device 0: bcm2835 ALSA [bcm2835 ALSA] Subdevices: 7/7 Subdevice #0: subdevice #0 Subdevice #1: subdevice #1 Subdevice #2: subdevice #2 Subdevice #3: subdevice #3 Subdevice #4: subdevice #4 Subdevice #5: subdevice #5 Subdevice #6: subdevice #6 card 0: ALSA [bcm2835 ALSA], device 1: bcm2835 IEC958/HDMI [bcm2835 IEC958/HDMI] Subdevices: 1/1 Subdevice #0: subdevice #0 card 0: ALSA [bcm2835 ALSA], device 2: bcm2835 IEC958/HDMI1 [bcm2835 IEC958/HDMI1] Subdevices: 1/1 Subdevice #0: subdevice #0 card 1: Device [C-Media USB Audio Device], device 0: USB Audio [USB Audio] Subdevices: 1/1 Subdevice #0: subdevice #0 Wir betrachten das letzte Ger\u00e4t: card 1: Device [C-Media USB Audio Device], device 0: USB Audio [USB Audio] In dem Fall ist das letzte Ger\u00e4t - card 1 - unsere USB-Audio Schnittstelle die wir verwenden wollen. In der Konfiguration wird das Feld card nun auf den Wert 1 gesetzt. Nach dem Typ der Soundkarte steht das device, in diesem Fall device 0 . In der Konfiguration wird das Feld device nun auf den Wert 0 gesetzt. Beispiel: inputSource: ... lineIn: card: 1 device: 0 PulseAudio: Feld Beschreibung Default device Der Sinks-Name der Quelle boswatch Device herausfinden Durch eingabe des Befehls pacmd list-sinks | grep name: werden alle Sinks ausgegeben. Beispiel: bash-5.0# pacmd list-sinks | grep name: name: <boswatch> In der Konfiguration wird das Feld device nun auf den den Namen des gew\u00fcnschten Sinks gesetzt (ohne spitze Klammern, <>). Beispiel: inputSource: ... PulseAudio: device: boswatch decoder: Feld Beschreibung Default fms FMS Decoder no zvei ZVEI Decoder no poc512 POCSAG Decoder (Bitrate 512) no poc1200 POCSAG Decoder (Bitrate 1200) no poc2400 POCSAG Decoder (Bitrate 2400) no path Pfad zur multimon-ng Binary multimon-ng char multimon-ng char-Set not set Beispiel: decoder: fms: yes zvei: yes poc512: no poc1200: no poc2400: yes path: /opt/multimon/multimon-ng char: DE Server Nachfolgend alle Paramater der Server Konfiguration server: Feld Beschreibung Default port Port auf dem der Server lauscht 8080 name Name zur Identifizierung der Server Instanz useBroadcast Verbindungsdaten per Broadcast Server bereitstellen no alarmRouter: Enth\u00e4lt eine Liste der Router Namen, welche bei einem Alarm direkt gestartet werden sollen. Beispiel: alarmRouter: - Name des Routers - ein weiter Router router: Mit den Routern kann der Verarbeitungsweg eines Alarm-Paketes festgelegt werden. Es k\u00f6nnen beliebig viele Router in Form einer Liste angegeben werden. Feld Beschreibung Default name Name des Routers route Definiten des Routenverlaufs route: Jeder Router kann eine beliebige Anzahl einzelner Routenpunkte enthalten. Diese werden innerhalb des Routers sequentiel abgearbeitet. M\u00f6gliche Typen der Routenpunkte sind dabei ein Modul, ein Plugin oder ein anderer Router. Sie werden ebenfalls in Form einer Liste definiert. Feld Beschreibung Default type Art des Routenpunktes (module, plugin, router) res Zu ladende Resource (Siehe entsprechende Kapitel) name Optionaler Name des Routenpunktes gleich wie Resource config Konfigurationseinstellungen des Routenpunktes (Siehe entsprechende Kapitel) Beispiel: router: - name: Router 1 route: - type: module res: filter.modeFilter name: Filter Fms/Zvei config: allowed: - fms Module/Plugins Die m\u00f6glichen Einstellungen der einzelnen Module und Plugins sind im jeweiligen Kapitel aufgelistet.","title":"Konfiguration"},{"location":"config.html#konfiguration","text":"Die Konfiguration von BOSWatch 3 ist im YAML Format abgelegt und wird nachfolgend beschrieben. Immer wenn f\u00fcr eine Einstellung ein Default Wert angegeben ist, muss diese Einstellung nicht zwingend in die Konfiguration eingetragen werden.","title":"Konfiguration"},{"location":"config.html#client","text":"","title":"Client"},{"location":"config.html#client_1","text":"Feld Beschreibung Default name Name zur Identifizierung der Client Instanz inputSource Art der zu nutzenden Input Quelle ( sdr , lineIn oder PulseAudio ) useBroadcast Verbindungsdaten per Broadcast beziehen no reconnectDelay Verz\u00f6gerung f\u00fcr erneuten Verbindungsversuch zum Server 3 sendTries Anzahl der Sendeversuche eines Pakets 3 sendDelay Verz\u00f6gerung f\u00fcr einen erneuten Sendeversuch 3","title":"client:"},{"location":"config.html#server","text":"Der Abschnitt server: wird nur genutzt, wenn useBroadcast: no gesetzt ist. Ansonsten wird versucht die Verbindungsdaten per Broadcast Paket direkt vom Server zu beziehen. Feld Beschreibung Default ip IP Adresse des Servers 127.0.0.1 port Port des Sever 8080 Beispiel: server: ip: 10.10.10.2 port: 9123","title":"server:"},{"location":"config.html#inputsource","text":"Es gibt die Auswahl zwischen sdr , lineIn oder PulseAudio als Input Quelle. Mit sdr wird direkt per rtl_sdr die zu empfangende Frequenz an Multimon-NG weitergereicht. Mit lineIn wird eine Quelle die (per ALSA ) direkt an die Soundkarte angeschlossen ist an Multimon-NG weitergereicht. Mit PulseAudio wird ein PulseAudio-Sink an Multimon-NG weitergereicht, z.B. in Kombination mit RTLSDR-Airband und/oder Docker.","title":"inputSource:"},{"location":"config.html#sdr","text":"Feld Beschreibung Default device rtl_fm Device ID 0 frequency Zu empfangende Frequenz error Frequenz Abweichung in ppm 0 squelch Einstellung der Rauschsperre 1 gain Verst\u00e4rkung des Eingangssignals 100 fir_size niedrig leckagearmen Filter None rtlPath Pfad zur rtl_fm Binary rtl_fm Beispiel: inputSource: sdr: device: 0 frequency: 85M error: 0 squelch: 1 gain: 100 rtlPath: /usr/bin/rtl-fm","title":"sdr:"},{"location":"config.html#linein","text":"Feld Beschreibung Default device die device Id der Soundkarte 1 Device herausfinden Durch eingabe des Befehls aplay -l werden alle Soundkarten ausgegeben. Das schaut ungef\u00e4hr so aus: **** List of PLAYBACK Hardware Devices **** card 0: ALSA [bcm2835 ALSA], device 0: bcm2835 ALSA [bcm2835 ALSA] Subdevices: 7/7 Subdevice #0: subdevice #0 Subdevice #1: subdevice #1 Subdevice #2: subdevice #2 Subdevice #3: subdevice #3 Subdevice #4: subdevice #4 Subdevice #5: subdevice #5 Subdevice #6: subdevice #6 card 0: ALSA [bcm2835 ALSA], device 1: bcm2835 IEC958/HDMI [bcm2835 IEC958/HDMI] Subdevices: 1/1 Subdevice #0: subdevice #0 card 0: ALSA [bcm2835 ALSA], device 2: bcm2835 IEC958/HDMI1 [bcm2835 IEC958/HDMI1] Subdevices: 1/1 Subdevice #0: subdevice #0 card 1: Device [C-Media USB Audio Device], device 0: USB Audio [USB Audio] Subdevices: 1/1 Subdevice #0: subdevice #0 Wir betrachten das letzte Ger\u00e4t: card 1: Device [C-Media USB Audio Device], device 0: USB Audio [USB Audio] In dem Fall ist das letzte Ger\u00e4t - card 1 - unsere USB-Audio Schnittstelle die wir verwenden wollen. In der Konfiguration wird das Feld card nun auf den Wert 1 gesetzt. Nach dem Typ der Soundkarte steht das device, in diesem Fall device 0 . In der Konfiguration wird das Feld device nun auf den Wert 0 gesetzt. Beispiel: inputSource: ... lineIn: card: 1 device: 0","title":"lineIn:"},{"location":"config.html#pulseaudio","text":"Feld Beschreibung Default device Der Sinks-Name der Quelle boswatch Device herausfinden Durch eingabe des Befehls pacmd list-sinks | grep name: werden alle Sinks ausgegeben. Beispiel: bash-5.0# pacmd list-sinks | grep name: name: <boswatch> In der Konfiguration wird das Feld device nun auf den den Namen des gew\u00fcnschten Sinks gesetzt (ohne spitze Klammern, <>). Beispiel: inputSource: ... PulseAudio: device: boswatch","title":"PulseAudio:"},{"location":"config.html#decoder","text":"Feld Beschreibung Default fms FMS Decoder no zvei ZVEI Decoder no poc512 POCSAG Decoder (Bitrate 512) no poc1200 POCSAG Decoder (Bitrate 1200) no poc2400 POCSAG Decoder (Bitrate 2400) no path Pfad zur multimon-ng Binary multimon-ng char multimon-ng char-Set not set Beispiel: decoder: fms: yes zvei: yes poc512: no poc1200: no poc2400: yes path: /opt/multimon/multimon-ng char: DE","title":"decoder:"},{"location":"config.html#server_1","text":"Nachfolgend alle Paramater der Server Konfiguration","title":"Server"},{"location":"config.html#server_2","text":"Feld Beschreibung Default port Port auf dem der Server lauscht 8080 name Name zur Identifizierung der Server Instanz useBroadcast Verbindungsdaten per Broadcast Server bereitstellen no","title":"server:"},{"location":"config.html#alarmrouter","text":"Enth\u00e4lt eine Liste der Router Namen, welche bei einem Alarm direkt gestartet werden sollen. Beispiel: alarmRouter: - Name des Routers - ein weiter Router","title":"alarmRouter:"},{"location":"config.html#router","text":"Mit den Routern kann der Verarbeitungsweg eines Alarm-Paketes festgelegt werden. Es k\u00f6nnen beliebig viele Router in Form einer Liste angegeben werden. Feld Beschreibung Default name Name des Routers route Definiten des Routenverlaufs","title":"router:"},{"location":"config.html#route","text":"Jeder Router kann eine beliebige Anzahl einzelner Routenpunkte enthalten. Diese werden innerhalb des Routers sequentiel abgearbeitet. M\u00f6gliche Typen der Routenpunkte sind dabei ein Modul, ein Plugin oder ein anderer Router. Sie werden ebenfalls in Form einer Liste definiert. Feld Beschreibung Default type Art des Routenpunktes (module, plugin, router) res Zu ladende Resource (Siehe entsprechende Kapitel) name Optionaler Name des Routenpunktes gleich wie Resource config Konfigurationseinstellungen des Routenpunktes (Siehe entsprechende Kapitel) Beispiel: router: - name: Router 1 route: - type: module res: filter.modeFilter name: Filter Fms/Zvei config: allowed: - fms","title":"route:"},{"location":"config.html#moduleplugins","text":"Die m\u00f6glichen Einstellungen der einzelnen Module und Plugins sind im jeweiligen Kapitel aufgelistet.","title":"Module/Plugins"},{"location":"tbd.html","text":"To be done ... Hier existiert noch kein Inhalt, gerne kannst du uns aber Helfen die Dokumentation zu vervollst\u00e4ndigen.","title":"Installation"},{"location":"tbd.html#to-be-done","text":"Hier existiert noch kein Inhalt, gerne kannst du uns aber Helfen die Dokumentation zu vervollst\u00e4ndigen.","title":"To be done ..."},{"location":"develop/ModulPlugin.html","text":"Eigenes Modul/Plugin schreiben Um ein eigenes Modul oder Plugin zu schreiben, sollte man sich am besten zuerst einmal das das template im entsprechenden Ordner ansehen. Dies kann als Vorlage f\u00fcr das eigene Modul oder Plugin genutzt werden. Allgemeine Informationen Im ersten Schritt sollte eine Kopie des jeweiligen Templates (Modul oder Plugin) erstellt werden. Nun sollten im Dateikopf die Angaben angepasst werden. Ben\u00f6tigte Methoden \u00fcberschreiben Modul Die Modul Basisklasse bietet einige Methoden, welche vom Modul \u00fcberschrieben werden k\u00f6nnen. onLoad() wird direkt beim Import des Moduls ausgef\u00fchrt doWork(bwPacket) wird bei der Ausf\u00fchrung aufgerufen onUnload() wird beim Zerst\u00f6ren der Plugin Modul zum Programmende ausgef\u00fchrt Plugin Die Plugin Basisklasse bietet einige Methoden, welche vom Plugin \u00fcberschrieben werden k\u00f6nnen. onLoad() wird direkt beim Import des Plugins ausgef\u00fchrt setup() wird vor jeder Ausf\u00fchrung gerufen fms(bwPacket) wird bei einem FMS Paket ausgef\u00fchrt pocsag(bwPacket) wird bei einem POCSAG Paket ausgef\u00fchrt zvei(bwPacket) wird bei einem ZVEI Packet ausgef\u00fchrt msg(bwPacket) wird bei einem Nachrichten Packet ausgef\u00fchrt teardown() wird nach jeder Ausf\u00fchrung gerufen onUnload() wird beim Zerst\u00f6ren der Plugin Instanz zum Programmende ausgef\u00fchrt Konfiguration Konfiguration anlegen Jedes Modul oder Plugin wird in einem Router folgenderma\u00dfen deklariert: - type: module # oder 'plugin' res: template_module # Name der Python Datei (ohne .py) name: Mein Modul # optionaler Name config: # config-Sektion option1: value 1 option2: underOption1: value 21 underOption2: value 22 list: - list 1 - list 2 Eine entsprechende Dokumentation der Parameter muss in der Dokumentation des jeweiligen Moduls oder Plugins hinterleget werden. Konfiguration verwenden Wird der Instanz eine Konfiguration \u00fcbergeben wird diese in self.config abgelegt und kann wie folgt abgerufen werden: (Dies Ergebnisse beziehen sich auf das Konfigurationsbeispiel oben) Einzelnes Feld auslesen self.config.get(\"option1\") liefert value 1 Verschachteltes Feld auslesen (beliebige tiefe m\u00f6glich) self.config.get(\"option2\", \"underOption1\") liefert value 21 Es kann ein Default Wert angegeben werden (falls entsprechender Eintrag fehlt) self.config.get(\"notSet\", default=\"defValue\") liefert defValue \u00dcber Listen kann einfach iteriert werden for item in self.config.get(FIELD): liefert ein Element je Iteration - hier list 1 und list 2 Wird ein End-Wert ausgelesen, wird dieser direkt zur\u00fcck gegeben. Sollten weitere Unterelemente oder eine Liste exisitieren wird erneut ein Objekt der Klasse Config() zur\u00fcck gegeben, auf welches wiederum nach obigem Schema zugegriffen werden kann. Arbeiten mit dem bwPacket An das Modul bzw. Plugin wird eine Instanz eines BOSWatch-Paket Objekts \u00fcbergeben. Aus dieser kann mittels bwPacket.get(FIELDNAME) das entsprechende Feld ausgelesen werden. Mittels bwPacket.set(FIELDNAME, VALUE) kann ein Wert hinzugef\u00fcgt oder modifiziert werden. Eine Auflistung der bereitgestellten Informationen findet sich im entsprechenden BOSWatch Paket Dokumentation. Bitte beachten: Selbst vom Modul hinzugef\u00fcgte Felder m\u00fcssen in der Modul Dokumentation unter Paket Modifikation aufgef\u00fchrt werden. Sollte ein Modul oder Plugin Felder benutzen, welche in einem anderen Modul erstellt werden, muss dies im Punkt Abh\u00e4nigkeiten des jeweiligen Moduls oder Plugins dokumentiert werden. R\u00fcckgabewert bei Modulen Module k\u00f6nnen Pakete beliebig ver\u00e4ndern. Diese \u00c4nderungen werden im Router entsprechend weitergeleitet. M\u00f6gliche R\u00fcckgabewerte eines Moduls: return bwPacket Gibt das modifizierte bwPacket an den Router zur\u00fcck (Paket Modifikation) return None Der Router f\u00e4hrt mit dem unver\u00e4nderten bwPacket fort (Input = Output) return False Der Router stopt sofort die Ausf\u00fchrung (zB. in Filtern verwendet) R\u00fcckgabewert bei Plugins Plugins geben keine Pakete mehr zur\u00fcck. Sie fungieren ausschlie\u00dflich als Endpunkt. Die Plugin Basisklasse liefert intern immer ein None an den Router zur\u00fcck, was zur weiteren Ausf\u00fchrung des Routers mit dem original Paket f\u00fchrt. Daher macht es in Plugins keinen Sinn ein Paket zu modifizieren. Nutzung der Wildcards Es gibt einige vordefinierte Wildcards welche in der BOSWatch Paket Dokumentation zu finden sind. Au\u00dferdem sind die folgenden allgemeinen Wildcards definiert: {BR} - Zeilenumbruch \\r\\n {LPAR} - \u00f6ffnende Klammer ( {RPAR} - schlie\u00dfende Klammer ) {TIME} - Aktueller Zeitstempel im Format %d.%m.%Y %H:%M:%S Wildcards registrieren [Module] Module k\u00f6nnen zus\u00e4tzliche Wildcards registrieren welche anschlie\u00dfend in den Plugins ebenfalls geparst werden k\u00f6nnen. Dies kann \u00fcber die interne Methode self.registerWildcard(newWildcard, bwPacketField) gemacht werden. newWildcard muss im folgenden Format angegeben werden: {WILDCARD} bwPacketField ist der Name des Feldes im bwPacket - gestezt per bwPacket.set(FIELDNAME, VALUE) Bitte beachten: Selbst vom Modul registrierte Wildcards m\u00fcssen in der Modul Dokumentation unter Zus\u00e4tzliche Wildcards aufgef\u00fchrt werden. Wildcards parsen [Plugins] Das parsen der Wildcars funktioniert komfortabel \u00fcber die interne Methode msg = self.parseWildcards(msg) . msg enstrpicht dabei dem String in welchem die Wildcards ersetzt werden sollen Die Platzhalter der Wildcards findet man in der BOSWatch Paket Dokumentation. Sollten Module zus\u00e4tzliche Wildcards registrieren, findet man Informationen dazu in der jeweiligen Modul Dokumentation Richtiges Logging tbd ...","title":"Eigenes Modul/Plugin schreiben"},{"location":"develop/ModulPlugin.html#eigenes-modulplugin-schreiben","text":"Um ein eigenes Modul oder Plugin zu schreiben, sollte man sich am besten zuerst einmal das das template im entsprechenden Ordner ansehen. Dies kann als Vorlage f\u00fcr das eigene Modul oder Plugin genutzt werden.","title":"Eigenes Modul/Plugin schreiben"},{"location":"develop/ModulPlugin.html#allgemeine-informationen","text":"Im ersten Schritt sollte eine Kopie des jeweiligen Templates (Modul oder Plugin) erstellt werden. Nun sollten im Dateikopf die Angaben angepasst werden.","title":"Allgemeine Informationen"},{"location":"develop/ModulPlugin.html#benotigte-methoden-uberschreiben","text":"","title":"Ben\u00f6tigte Methoden \u00fcberschreiben"},{"location":"develop/ModulPlugin.html#modul","text":"Die Modul Basisklasse bietet einige Methoden, welche vom Modul \u00fcberschrieben werden k\u00f6nnen. onLoad() wird direkt beim Import des Moduls ausgef\u00fchrt doWork(bwPacket) wird bei der Ausf\u00fchrung aufgerufen onUnload() wird beim Zerst\u00f6ren der Plugin Modul zum Programmende ausgef\u00fchrt","title":"Modul"},{"location":"develop/ModulPlugin.html#plugin","text":"Die Plugin Basisklasse bietet einige Methoden, welche vom Plugin \u00fcberschrieben werden k\u00f6nnen. onLoad() wird direkt beim Import des Plugins ausgef\u00fchrt setup() wird vor jeder Ausf\u00fchrung gerufen fms(bwPacket) wird bei einem FMS Paket ausgef\u00fchrt pocsag(bwPacket) wird bei einem POCSAG Paket ausgef\u00fchrt zvei(bwPacket) wird bei einem ZVEI Packet ausgef\u00fchrt msg(bwPacket) wird bei einem Nachrichten Packet ausgef\u00fchrt teardown() wird nach jeder Ausf\u00fchrung gerufen onUnload() wird beim Zerst\u00f6ren der Plugin Instanz zum Programmende ausgef\u00fchrt","title":"Plugin"},{"location":"develop/ModulPlugin.html#konfiguration","text":"","title":"Konfiguration"},{"location":"develop/ModulPlugin.html#konfiguration-anlegen","text":"Jedes Modul oder Plugin wird in einem Router folgenderma\u00dfen deklariert: - type: module # oder 'plugin' res: template_module # Name der Python Datei (ohne .py) name: Mein Modul # optionaler Name config: # config-Sektion option1: value 1 option2: underOption1: value 21 underOption2: value 22 list: - list 1 - list 2 Eine entsprechende Dokumentation der Parameter muss in der Dokumentation des jeweiligen Moduls oder Plugins hinterleget werden.","title":"Konfiguration anlegen"},{"location":"develop/ModulPlugin.html#konfiguration-verwenden","text":"Wird der Instanz eine Konfiguration \u00fcbergeben wird diese in self.config abgelegt und kann wie folgt abgerufen werden: (Dies Ergebnisse beziehen sich auf das Konfigurationsbeispiel oben) Einzelnes Feld auslesen self.config.get(\"option1\") liefert value 1 Verschachteltes Feld auslesen (beliebige tiefe m\u00f6glich) self.config.get(\"option2\", \"underOption1\") liefert value 21 Es kann ein Default Wert angegeben werden (falls entsprechender Eintrag fehlt) self.config.get(\"notSet\", default=\"defValue\") liefert defValue \u00dcber Listen kann einfach iteriert werden for item in self.config.get(FIELD): liefert ein Element je Iteration - hier list 1 und list 2 Wird ein End-Wert ausgelesen, wird dieser direkt zur\u00fcck gegeben. Sollten weitere Unterelemente oder eine Liste exisitieren wird erneut ein Objekt der Klasse Config() zur\u00fcck gegeben, auf welches wiederum nach obigem Schema zugegriffen werden kann.","title":"Konfiguration verwenden"},{"location":"develop/ModulPlugin.html#arbeiten-mit-dem-bwpacket","text":"An das Modul bzw. Plugin wird eine Instanz eines BOSWatch-Paket Objekts \u00fcbergeben. Aus dieser kann mittels bwPacket.get(FIELDNAME) das entsprechende Feld ausgelesen werden. Mittels bwPacket.set(FIELDNAME, VALUE) kann ein Wert hinzugef\u00fcgt oder modifiziert werden. Eine Auflistung der bereitgestellten Informationen findet sich im entsprechenden BOSWatch Paket Dokumentation. Bitte beachten: Selbst vom Modul hinzugef\u00fcgte Felder m\u00fcssen in der Modul Dokumentation unter Paket Modifikation aufgef\u00fchrt werden. Sollte ein Modul oder Plugin Felder benutzen, welche in einem anderen Modul erstellt werden, muss dies im Punkt Abh\u00e4nigkeiten des jeweiligen Moduls oder Plugins dokumentiert werden.","title":"Arbeiten mit dem bwPacket"},{"location":"develop/ModulPlugin.html#ruckgabewert-bei-modulen","text":"Module k\u00f6nnen Pakete beliebig ver\u00e4ndern. Diese \u00c4nderungen werden im Router entsprechend weitergeleitet. M\u00f6gliche R\u00fcckgabewerte eines Moduls: return bwPacket Gibt das modifizierte bwPacket an den Router zur\u00fcck (Paket Modifikation) return None Der Router f\u00e4hrt mit dem unver\u00e4nderten bwPacket fort (Input = Output) return False Der Router stopt sofort die Ausf\u00fchrung (zB. in Filtern verwendet)","title":"R\u00fcckgabewert bei Modulen"},{"location":"develop/ModulPlugin.html#ruckgabewert-bei-plugins","text":"Plugins geben keine Pakete mehr zur\u00fcck. Sie fungieren ausschlie\u00dflich als Endpunkt. Die Plugin Basisklasse liefert intern immer ein None an den Router zur\u00fcck, was zur weiteren Ausf\u00fchrung des Routers mit dem original Paket f\u00fchrt. Daher macht es in Plugins keinen Sinn ein Paket zu modifizieren.","title":"R\u00fcckgabewert bei Plugins"},{"location":"develop/ModulPlugin.html#nutzung-der-wildcards","text":"Es gibt einige vordefinierte Wildcards welche in der BOSWatch Paket Dokumentation zu finden sind. Au\u00dferdem sind die folgenden allgemeinen Wildcards definiert: {BR} - Zeilenumbruch \\r\\n {LPAR} - \u00f6ffnende Klammer ( {RPAR} - schlie\u00dfende Klammer ) {TIME} - Aktueller Zeitstempel im Format %d.%m.%Y %H:%M:%S","title":"Nutzung der Wildcards"},{"location":"develop/ModulPlugin.html#wildcards-registrieren-module","text":"Module k\u00f6nnen zus\u00e4tzliche Wildcards registrieren welche anschlie\u00dfend in den Plugins ebenfalls geparst werden k\u00f6nnen. Dies kann \u00fcber die interne Methode self.registerWildcard(newWildcard, bwPacketField) gemacht werden. newWildcard muss im folgenden Format angegeben werden: {WILDCARD} bwPacketField ist der Name des Feldes im bwPacket - gestezt per bwPacket.set(FIELDNAME, VALUE) Bitte beachten: Selbst vom Modul registrierte Wildcards m\u00fcssen in der Modul Dokumentation unter Zus\u00e4tzliche Wildcards aufgef\u00fchrt werden.","title":"Wildcards registrieren [Module]"},{"location":"develop/ModulPlugin.html#wildcards-parsen-plugins","text":"Das parsen der Wildcars funktioniert komfortabel \u00fcber die interne Methode msg = self.parseWildcards(msg) . msg enstrpicht dabei dem String in welchem die Wildcards ersetzt werden sollen Die Platzhalter der Wildcards findet man in der BOSWatch Paket Dokumentation. Sollten Module zus\u00e4tzliche Wildcards registrieren, findet man Informationen dazu in der jeweiligen Modul Dokumentation","title":"Wildcards parsen [Plugins]"},{"location":"develop/ModulPlugin.html#richtiges-logging","text":"tbd ...","title":"Richtiges Logging"},{"location":"develop/packet.html","text":"BOSWatch Paket Format Ein BOSWatch Datenpaket wird in einem Python Dict abgebildet. In der nachfolgenden Tabelle sind die genutzten Felder abgebildet. Allgemeine Informationen Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung serverName X X X X {SNAME} Name der BOSWatch Server Instanz serverVersion X X X X {SVERS} serverBuildDate X X X X {SDATE} serverBranch X X X X {SBRCH} clientName X X X X {CNAME} Name der BOSWatch Client Instanz clientIP X X X X {CIP} clientVersion X X X X {CVERS} clientBuildDate X X X X {CDATE} clientBranch X X X X {CBRCH} inputSource X X X X {INSRC} (sdr, audio) timestamp X X X X {TIMES} frequency X X X X {FREQ} mode X X X X {MODE} (fms, pocsag, zvei, msg) Speziell f\u00fcr POCSAG Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung bitrate X {BIT} ric X {RIC} subric X {SRIC} (1, 2, 3, 4) subricText X {SRICT} (a, b, c, d) message X X {MSG} Kann au\u00dferdem f\u00fcr ein Message Paket genutzt werden Speziell f\u00fcr ZVEI Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung tone X {TONE} 5-Ton Sequenz nach ZVEI Speziell f\u00fcr FMS Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung fms X {FMS} service X {SERV} country X {COUNT} location X {LOC} vehicle X {VEC} status X {STAT} direction X {DIR} directionText X {DIRT} (Fhz->Lst, Lst->Fhz) tacticalInfo X {TACI} (I, II, III, IV)","title":"BOSWatch Alarmpaket Format"},{"location":"develop/packet.html#boswatch-paket-format","text":"Ein BOSWatch Datenpaket wird in einem Python Dict abgebildet. In der nachfolgenden Tabelle sind die genutzten Felder abgebildet.","title":"BOSWatch Paket Format"},{"location":"develop/packet.html#allgemeine-informationen","text":"Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung serverName X X X X {SNAME} Name der BOSWatch Server Instanz serverVersion X X X X {SVERS} serverBuildDate X X X X {SDATE} serverBranch X X X X {SBRCH} clientName X X X X {CNAME} Name der BOSWatch Client Instanz clientIP X X X X {CIP} clientVersion X X X X {CVERS} clientBuildDate X X X X {CDATE} clientBranch X X X X {CBRCH} inputSource X X X X {INSRC} (sdr, audio) timestamp X X X X {TIMES} frequency X X X X {FREQ} mode X X X X {MODE} (fms, pocsag, zvei, msg)","title":"Allgemeine Informationen"},{"location":"develop/packet.html#speziell-fur-pocsag","text":"Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung bitrate X {BIT} ric X {RIC} subric X {SRIC} (1, 2, 3, 4) subricText X {SRICT} (a, b, c, d) message X X {MSG} Kann au\u00dferdem f\u00fcr ein Message Paket genutzt werden","title":"Speziell f\u00fcr POCSAG"},{"location":"develop/packet.html#speziell-fur-zvei","text":"Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung tone X {TONE} 5-Ton Sequenz nach ZVEI","title":"Speziell f\u00fcr ZVEI"},{"location":"develop/packet.html#speziell-fur-fms","text":"Feldname FMS POCSAG ZVEI MSG Wildcard Beschreibung fms X {FMS} service X {SERV} country X {COUNT} location X {LOC} vehicle X {VEC} status X {STAT} direction X {DIR} directionText X {DIRT} (Fhz->Lst, Lst->Fhz) tacticalInfo X {TACI} (I, II, III, IV)","title":"Speziell f\u00fcr FMS"},{"location":"information/broadcast.html","text":"Broadcast Service Durch den Broadcast Service haben Clients die M\u00f6glichkeit, automatisch den Server zu finden und sich mit diesem zu verbinden. Dazu stellt der Server die ben\u00f6tigten Verbinungsinformationen per Broadcast Service bereit. Hinweis: Server und Client m\u00fcssen sich im selben Subnetz befinden. Aufbau Der Broadcast Service besteht aus 2 Teilen - einem Server und einem Clienten. Nachfolgend soll der Ablauf einer Verbindung des Clienten zum Server mittels des Broadcast Services erkl\u00e4rt werden. Ablauf Schritt 1 - Broadcast Server starten Im ersten Schritt wird auf dem Server ein zus\u00e4tzlicher Broadcast Server in einem seperaten Thread gestartet. Dieser lauscht auf einem festgelegten Port auf UDP Broadcast Pakete. Nun kann eine beliebige Anzahl von Clienten mittels des Broadcast Services die Verbindungsgdaten des Servers abfragen. Schritt 2 - Broadcast durch Clienten Die Client Applikation startet nun zur Abfrage der Verbindungsdaten einen BC Clienten und sendet dort auf dem festgelegten Port ein Paket per UDP Boradcast. Der Inhalt des Paketes ist das Magic-Word <BW3-Request> und wird von allen im selben Subnetz befindlichen Gegenstellen empfangen. Nun wartet der Client auf eine Antwort des Broadcast Server mit den Verbindungsdaten. Schritt 3 - Verbindungsdaten senden Wird nun ein Broadcast Paket empfangen, pr\u00fcft der BC Server die Daten auf das Magic-Word <BW3-Request> . Wird dieses erkannt, liest der Server die Absender-IP-Addresse aus dem Paket aus und sendet eine Antwort direkt an diesen Clienten. Dieses Antwortpaket sieht folgenderma\u00dfen aus: <BW3-Result>;8080 wobei die 8080 hier den normalen TCP Kommunikationsport des Servers darstellt. Schritt 4 - Verbindungsdaten empfangen Nachdem der Client das direkt an ihn gerichtete Paket mit den Verbindungsdaten vom Server empfangen hat, pr\u00fcft er auf das Magic-Word <BW3-Result> . Ist dieses enthalten wird der Port f\u00fcr die TCP Verbindung aus dem Paket extrahiert. Au\u00dferdem wird die IP-Addresse des Absenders aus dem Paket gelesen. Anschlie\u00dfend stehen dem Clienten die Verbindungsdaten des Servers zur Verf\u00fcgung und er kann sich per TCP auf den angegebenen Port mit dem BOSWatch Server verbinden um seine Alarmierungs-Pakete abzusetzen. Da der Broadcast Server in einem eigenen Thread, unabh\u00e4ngig vom Hauptprogram l\u00e4uft, k\u00f6nnen ganz einfach weitere Clienten per Broadcast Service die Verbindungsdaten des Servers abrufen.","title":"Broadcast Service"},{"location":"information/broadcast.html#broadcast-service","text":"Durch den Broadcast Service haben Clients die M\u00f6glichkeit, automatisch den Server zu finden und sich mit diesem zu verbinden. Dazu stellt der Server die ben\u00f6tigten Verbinungsinformationen per Broadcast Service bereit. Hinweis: Server und Client m\u00fcssen sich im selben Subnetz befinden.","title":"Broadcast Service"},{"location":"information/broadcast.html#aufbau","text":"Der Broadcast Service besteht aus 2 Teilen - einem Server und einem Clienten. Nachfolgend soll der Ablauf einer Verbindung des Clienten zum Server mittels des Broadcast Services erkl\u00e4rt werden.","title":"Aufbau"},{"location":"information/broadcast.html#ablauf","text":"","title":"Ablauf"},{"location":"information/broadcast.html#schritt-1-broadcast-server-starten","text":"Im ersten Schritt wird auf dem Server ein zus\u00e4tzlicher Broadcast Server in einem seperaten Thread gestartet. Dieser lauscht auf einem festgelegten Port auf UDP Broadcast Pakete. Nun kann eine beliebige Anzahl von Clienten mittels des Broadcast Services die Verbindungsgdaten des Servers abfragen.","title":"Schritt 1 - Broadcast Server starten"},{"location":"information/broadcast.html#schritt-2-broadcast-durch-clienten","text":"Die Client Applikation startet nun zur Abfrage der Verbindungsdaten einen BC Clienten und sendet dort auf dem festgelegten Port ein Paket per UDP Boradcast. Der Inhalt des Paketes ist das Magic-Word <BW3-Request> und wird von allen im selben Subnetz befindlichen Gegenstellen empfangen. Nun wartet der Client auf eine Antwort des Broadcast Server mit den Verbindungsdaten.","title":"Schritt 2 - Broadcast durch Clienten"},{"location":"information/broadcast.html#schritt-3-verbindungsdaten-senden","text":"Wird nun ein Broadcast Paket empfangen, pr\u00fcft der BC Server die Daten auf das Magic-Word <BW3-Request> . Wird dieses erkannt, liest der Server die Absender-IP-Addresse aus dem Paket aus und sendet eine Antwort direkt an diesen Clienten. Dieses Antwortpaket sieht folgenderma\u00dfen aus: <BW3-Result>;8080 wobei die 8080 hier den normalen TCP Kommunikationsport des Servers darstellt.","title":"Schritt 3 - Verbindungsdaten senden"},{"location":"information/broadcast.html#schritt-4-verbindungsdaten-empfangen","text":"Nachdem der Client das direkt an ihn gerichtete Paket mit den Verbindungsdaten vom Server empfangen hat, pr\u00fcft er auf das Magic-Word <BW3-Result> . Ist dieses enthalten wird der Port f\u00fcr die TCP Verbindung aus dem Paket extrahiert. Au\u00dferdem wird die IP-Addresse des Absenders aus dem Paket gelesen. Anschlie\u00dfend stehen dem Clienten die Verbindungsdaten des Servers zur Verf\u00fcgung und er kann sich per TCP auf den angegebenen Port mit dem BOSWatch Server verbinden um seine Alarmierungs-Pakete abzusetzen. Da der Broadcast Server in einem eigenen Thread, unabh\u00e4ngig vom Hauptprogram l\u00e4uft, k\u00f6nnen ganz einfach weitere Clienten per Broadcast Service die Verbindungsdaten des Servers abrufen.","title":"Schritt 4 - Verbindungsdaten empfangen"},{"location":"information/router.html","text":"Routing Mechanismus BOSWatch 3 hat einen Routing Mechanismus integriert. Mit diesem ist es auf einfache Weise m\u00f6glich, den Verlauf von Alarmpaketen zu steuern. Ablauf Nachfolgender Ablauf soll am Beispiel eines Alarms mit einem Pocsag Paket erkl\u00e4rt werden. BOSWatch startet alle Router, welche in der config als alarmRouter konfiguriert worden sind (in diesem Fall nur Router1 ) Der Router Router1 beginnt seine Ausf\u00fchrung und arbeitet die einzelnen Routenpunkte sequentiell ab Das Modul descriptor wird aufgerufen und f\u00fcgt ggf. Beschreibungen zum Paket hinzu Das Modul doubleFilter wird aufgerufen und blockiert doppelte Alarme (hier w\u00fcrde die Ausf\u00fchrung dieses Routers und damit des kompletten Alarmprozesses stoppen wenn der Alarm als doppelter erkannt w\u00fcrde) Der Router Router2 wir nun aufgerufen (bis zur R\u00fcckkehr aus Router2 ist der Router Router1 angehalten) Der Router Router2 beginnt seine Ausf\u00fchrung und arbeitet die einzelnen Routenpunkte sequentiell ab Das Modul modeFilter wird aufgerufen und stoppt den Router da es sich nicht um ein FMS Paket handelt Es wird zur Ausf\u00fchrung von Router1 zur\u00fcckgekehrt Der Router Router3 beginnt seine Ausf\u00fchrung und arbeitet die einzelnen Routenpunkte sequentiell ab Das Modul modeFilter wird aufgerufen und leitet das Paket weiter da es sich um ein Pocsag Paket handelt Das Plugin Telegram wird aufgerufen Das Plugin MySQL wird augerufen Es wird zur Ausf\u00fchrung von Router1 zur\u00fcckgekehrt Der Router Router1 setzt seine Ausf\u00fchrung fort Das Modul modeFilter wird aufgerufen und stoppt den Router da es sich nicht um ein ZVEI Paket handelt Jetzt sind alle Routenpunkte abgearbeitet und die Alarmierung damit abgeschlossen. Konfiguration Nachfolgend ist die Router Konfiguration des BW3-Servers f\u00fcr das obige Beispiel zu finden: alarmRouter: - Router1 router: - name: Router1 route: - type: module res: descriptor config: [...] - type: module res: filter.doubleFilter config: [...] - type: router res: Router2 - type: router res: Router3 - type: module res: filter.modeFilter config: allowed: - zvei - type: plugin res: sms config: [...] - name: Router2 route: - type: module res: filter.modeFilter config: allowed: - fms - type: plugin res: mysql config: [...] - name: Router3 route: - type: module res: filter.modeFilter config: allowed: - pocsag - type: plugin res: telegram config: [...] - type: plugin res: mysql config: [...]","title":"Routing Mechanismus"},{"location":"information/router.html#routing-mechanismus","text":"BOSWatch 3 hat einen Routing Mechanismus integriert. Mit diesem ist es auf einfache Weise m\u00f6glich, den Verlauf von Alarmpaketen zu steuern.","title":"Routing Mechanismus"},{"location":"information/router.html#ablauf","text":"Nachfolgender Ablauf soll am Beispiel eines Alarms mit einem Pocsag Paket erkl\u00e4rt werden. BOSWatch startet alle Router, welche in der config als alarmRouter konfiguriert worden sind (in diesem Fall nur Router1 ) Der Router Router1 beginnt seine Ausf\u00fchrung und arbeitet die einzelnen Routenpunkte sequentiell ab Das Modul descriptor wird aufgerufen und f\u00fcgt ggf. Beschreibungen zum Paket hinzu Das Modul doubleFilter wird aufgerufen und blockiert doppelte Alarme (hier w\u00fcrde die Ausf\u00fchrung dieses Routers und damit des kompletten Alarmprozesses stoppen wenn der Alarm als doppelter erkannt w\u00fcrde) Der Router Router2 wir nun aufgerufen (bis zur R\u00fcckkehr aus Router2 ist der Router Router1 angehalten) Der Router Router2 beginnt seine Ausf\u00fchrung und arbeitet die einzelnen Routenpunkte sequentiell ab Das Modul modeFilter wird aufgerufen und stoppt den Router da es sich nicht um ein FMS Paket handelt Es wird zur Ausf\u00fchrung von Router1 zur\u00fcckgekehrt Der Router Router3 beginnt seine Ausf\u00fchrung und arbeitet die einzelnen Routenpunkte sequentiell ab Das Modul modeFilter wird aufgerufen und leitet das Paket weiter da es sich um ein Pocsag Paket handelt Das Plugin Telegram wird aufgerufen Das Plugin MySQL wird augerufen Es wird zur Ausf\u00fchrung von Router1 zur\u00fcckgekehrt Der Router Router1 setzt seine Ausf\u00fchrung fort Das Modul modeFilter wird aufgerufen und stoppt den Router da es sich nicht um ein ZVEI Paket handelt Jetzt sind alle Routenpunkte abgearbeitet und die Alarmierung damit abgeschlossen.","title":"Ablauf"},{"location":"information/router.html#konfiguration","text":"Nachfolgend ist die Router Konfiguration des BW3-Servers f\u00fcr das obige Beispiel zu finden: alarmRouter: - Router1 router: - name: Router1 route: - type: module res: descriptor config: [...] - type: module res: filter.doubleFilter config: [...] - type: router res: Router2 - type: router res: Router3 - type: module res: filter.modeFilter config: allowed: - zvei - type: plugin res: sms config: [...] - name: Router2 route: - type: module res: filter.modeFilter config: allowed: - fms - type: plugin res: mysql config: [...] - name: Router3 route: - type: module res: filter.modeFilter config: allowed: - pocsag - type: plugin res: telegram config: [...] - type: plugin res: mysql config: [...]","title":"Konfiguration"},{"location":"information/serverclient.html","text":"Server/Client Prinzip BOSWatch 3 wurde als Server/Client Anwedung entwickelt. Dies erm\u00f6glicht es, mehrere Empfangsstationen an einer Auswerte- und Verteilereinheit zu b\u00fcndeln. BOSWatch Client Der BOSWatch Client \u00fcbernimmt den Empfang und die Dekodierung der Daten. Anschlie\u00dfend werden die Daten mittels der implemetierten Dekoder ausgewertet und in ein sogenanntes bwPacket verpackt. Dieses Paket wird anschlie\u00dfend in einer Sende-Queue abgelegt. Nun werden Pakete aus der Queue an den BOSWatch Server per TCP-Socket gesendet. Der Ansatz, Pakete statt dem direkten versenden vorher in einer Queue zwischen zu speichern, verhindert den Verlust von Paketen, sollte die Verbindung zum Server einmal abreisen. Nach einer erfolgreichen Wiederverbdingun k\u00f6nnen die wartenden Pakete nun nachtr\u00e4glich an den Server \u00fcbermittelt werden. Dabei \u00fcberwacht der Client selbstst\u00e4ndig die ben\u00f6tigten Programme zum Empfang der Daten und startet diese bei einem Fehler ggf. neu. BOSWatch Server Nachdem die Daten vom Clienten \u00fcber die TCP-Socket Verbindung empfangen wurden, \u00fcbernimmt der BOSWatch Server die weitere Verarbeitung der Daten. Auch hier werden die empfangenen Daten in From von bwPacket's in einer Queue abelegt um zu gew\u00e4hrleisten, das auch w\u00e4hrend einer l\u00e4nger dauernden Plugin Ausf\u00fchrung alle Pakete korrekt empfangen werden k\u00f6nnen und es zu keinen Verlusten kommt. Die Verarbeitung der Pakete geschieht anschlie\u00dfend in sogenannten Routern, welche aufgrund ihres Umfangs jedoch in einem eigenen Kapitel erkl\u00e4rt werden. Diese steuern die Verteilung der Daten an die einzelnen Plugins.","title":"Server/Cient Prinzip"},{"location":"information/serverclient.html#serverclient-prinzip","text":"BOSWatch 3 wurde als Server/Client Anwedung entwickelt. Dies erm\u00f6glicht es, mehrere Empfangsstationen an einer Auswerte- und Verteilereinheit zu b\u00fcndeln.","title":"Server/Client Prinzip"},{"location":"information/serverclient.html#boswatch-client","text":"Der BOSWatch Client \u00fcbernimmt den Empfang und die Dekodierung der Daten. Anschlie\u00dfend werden die Daten mittels der implemetierten Dekoder ausgewertet und in ein sogenanntes bwPacket verpackt. Dieses Paket wird anschlie\u00dfend in einer Sende-Queue abgelegt. Nun werden Pakete aus der Queue an den BOSWatch Server per TCP-Socket gesendet. Der Ansatz, Pakete statt dem direkten versenden vorher in einer Queue zwischen zu speichern, verhindert den Verlust von Paketen, sollte die Verbindung zum Server einmal abreisen. Nach einer erfolgreichen Wiederverbdingun k\u00f6nnen die wartenden Pakete nun nachtr\u00e4glich an den Server \u00fcbermittelt werden. Dabei \u00fcberwacht der Client selbstst\u00e4ndig die ben\u00f6tigten Programme zum Empfang der Daten und startet diese bei einem Fehler ggf. neu.","title":"BOSWatch Client"},{"location":"information/serverclient.html#boswatch-server","text":"Nachdem die Daten vom Clienten \u00fcber die TCP-Socket Verbindung empfangen wurden, \u00fcbernimmt der BOSWatch Server die weitere Verarbeitung der Daten. Auch hier werden die empfangenen Daten in From von bwPacket's in einer Queue abelegt um zu gew\u00e4hrleisten, das auch w\u00e4hrend einer l\u00e4nger dauernden Plugin Ausf\u00fchrung alle Pakete korrekt empfangen werden k\u00f6nnen und es zu keinen Verlusten kommt. Die Verarbeitung der Pakete geschieht anschlie\u00dfend in sogenannten Routern, welche aufgrund ihres Umfangs jedoch in einem eigenen Kapitel erkl\u00e4rt werden. Diese steuern die Verteilung der Daten an die einzelnen Plugins.","title":"BOSWatch Server"},{"location":"modul/descriptor.html","text":"Descriptor Beschreibung Mit diesem Modul k\u00f6nnen einem Alarmpaket beliebige Beschreibungen in Abh\u00e4nigkeit der enthaltenen Informationen hinzugef\u00fcgt werden. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Msg Resource descriptor Konfiguration Informationen zum Aufbau eines BOSWatch Pakets Achtung: Zahlen welche f\u00fchrende Nullen entahlten m\u00fcssen in Anf\u00fchrungszeichen gesetzt werden Bsp. '0012345' Feld Beschreibung Default scanField Feld des BW Pakets welches gepr\u00fcft werden soll descrField Name des Feldes im BW Paket in welchem die Beschreibung gespeichert werden soll wildcard Optional: Es kann f\u00fcr das angelegte descrField automatisch ein Wildcard registriert werden None descriptions Liste der Beschreibungen descriptions: Feld Beschreibung Default for Inhalt im scanField auf welchem gepr\u00fcft werden soll add Beschreibungstext welcher im descrField hinterlegt werden soll Beispiel: - type: module res: descriptor config: - scanField: tone descrField: description wildcard: \"{DESCR}\" descriptions: - for: 12345 add: FF DescriptorTest - for: '05678' # f\u00fchrende Nullen in '' ! add: FF TestDescription - scanField: status descrField: fmsStatDescr wildcard: \"{STATUSTEXT}\" descriptions: - for: 1 add: Frei (Funk) - for: 2 add: Frei (Wache) - ... Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten keine Paket Modifikationen Wenn im Paket das Feld scanField vorhanden ist, wird das Feld descrField dem Paket hinzugef\u00fcgt Wenn keine Beschreibung vorhanden ist, wird im Feld descrField der Inhalt des Feldes scanField hinterlegt Zus\u00e4tzliche Wildcards Von der Konfiguration abh\u00e4ngig","title":"Descriptor"},{"location":"modul/descriptor.html#descriptor","text":"","title":"Descriptor"},{"location":"modul/descriptor.html#beschreibung","text":"Mit diesem Modul k\u00f6nnen einem Alarmpaket beliebige Beschreibungen in Abh\u00e4nigkeit der enthaltenen Informationen hinzugef\u00fcgt werden.","title":"Beschreibung"},{"location":"modul/descriptor.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei Msg","title":"Unterst\u00fctze Alarmtypen"},{"location":"modul/descriptor.html#resource","text":"descriptor","title":"Resource"},{"location":"modul/descriptor.html#konfiguration","text":"Informationen zum Aufbau eines BOSWatch Pakets Achtung: Zahlen welche f\u00fchrende Nullen entahlten m\u00fcssen in Anf\u00fchrungszeichen gesetzt werden Bsp. '0012345' Feld Beschreibung Default scanField Feld des BW Pakets welches gepr\u00fcft werden soll descrField Name des Feldes im BW Paket in welchem die Beschreibung gespeichert werden soll wildcard Optional: Es kann f\u00fcr das angelegte descrField automatisch ein Wildcard registriert werden None descriptions Liste der Beschreibungen","title":"Konfiguration"},{"location":"modul/descriptor.html#descriptions","text":"Feld Beschreibung Default for Inhalt im scanField auf welchem gepr\u00fcft werden soll add Beschreibungstext welcher im descrField hinterlegt werden soll Beispiel: - type: module res: descriptor config: - scanField: tone descrField: description wildcard: \"{DESCR}\" descriptions: - for: 12345 add: FF DescriptorTest - for: '05678' # f\u00fchrende Nullen in '' ! add: FF TestDescription - scanField: status descrField: fmsStatDescr wildcard: \"{STATUSTEXT}\" descriptions: - for: 1 add: Frei (Funk) - for: 2 add: Frei (Wache) - ...","title":"descriptions:"},{"location":"modul/descriptor.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"modul/descriptor.html#externe-abhangigkeiten","text":"keine","title":"Externe Abh\u00e4ngigkeiten"},{"location":"modul/descriptor.html#paket-modifikationen","text":"Wenn im Paket das Feld scanField vorhanden ist, wird das Feld descrField dem Paket hinzugef\u00fcgt Wenn keine Beschreibung vorhanden ist, wird im Feld descrField der Inhalt des Feldes scanField hinterlegt","title":"Paket Modifikationen"},{"location":"modul/descriptor.html#zusatzliche-wildcards","text":"Von der Konfiguration abh\u00e4ngig","title":"Zus\u00e4tzliche Wildcards"},{"location":"modul/double_filter.html","text":"Double Filter Beschreibung Mit diesem Modul ist es m\u00f6glich, die Pakete auf Duplikate zu Filtern. Je nach Konfiguration werden doppelte Pakete im aktuellen Router weitergeleitet oder verworfen. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Resource filter.doubleFilter Konfiguration Feld Beschreibung Default ignoreTime Zeitfenster f\u00fcr doppelte Pakte in Sekunden 10 maxEntry Maximale Anzahl an Paketen in der Vergleichsliste 20 pocsagFields Liste der Pocsag Felder zum Vergleichen: ric , subric und/oder message ric,subric Beispiel: - type: module res: filter.doubleFilter config: ignoreTime: 30 maxEntry: 10 pocsagFields: - ric - subric Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten keine Paket Modifikationen keine Zus\u00e4tzliche Wildcards keine","title":"Double Filter"},{"location":"modul/double_filter.html#double-filter","text":"","title":"Double Filter"},{"location":"modul/double_filter.html#beschreibung","text":"Mit diesem Modul ist es m\u00f6glich, die Pakete auf Duplikate zu Filtern. Je nach Konfiguration werden doppelte Pakete im aktuellen Router weitergeleitet oder verworfen.","title":"Beschreibung"},{"location":"modul/double_filter.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei","title":"Unterst\u00fctze Alarmtypen"},{"location":"modul/double_filter.html#resource","text":"filter.doubleFilter","title":"Resource"},{"location":"modul/double_filter.html#konfiguration","text":"Feld Beschreibung Default ignoreTime Zeitfenster f\u00fcr doppelte Pakte in Sekunden 10 maxEntry Maximale Anzahl an Paketen in der Vergleichsliste 20 pocsagFields Liste der Pocsag Felder zum Vergleichen: ric , subric und/oder message ric,subric Beispiel: - type: module res: filter.doubleFilter config: ignoreTime: 30 maxEntry: 10 pocsagFields: - ric - subric","title":"Konfiguration"},{"location":"modul/double_filter.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"modul/double_filter.html#externe-abhangigkeiten","text":"keine","title":"Externe Abh\u00e4ngigkeiten"},{"location":"modul/double_filter.html#paket-modifikationen","text":"keine","title":"Paket Modifikationen"},{"location":"modul/double_filter.html#zusatzliche-wildcards","text":"keine","title":"Zus\u00e4tzliche Wildcards"},{"location":"modul/geocoding.html","text":"Geocoding Beschreibung Mit diesem Modul k\u00f6nnen einem Paket die Koordinaten eines Ortes oder einer Adresse angef\u00fcgt werden. Unterst\u00fctzte Alarmtypen Pocsag Resource geocoding Konfiguration Feld Beschreibung Default apiProvider Der Provider f\u00fcr das Geocoding apiToken Der Api-Token fuer die Geocoding-Api geoRegex Regex Capture-Group zum Herausfiltern der Adresse Verf\u00fcgbare Geocoding Provider Name Einstellungswert Mapbox mapbox Google Maps google Beispiel: - type: module name: Geocoding Module res: geocoding config: apiProvider: \"{{ Provider f\u00fcr Geocoding }}\" apiToken: \"{{ API-Key f\u00fcr Provider }}\" regex: \"((?:[^ ]*,)*?)\" Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten geocoder Paket Modifikationen address : gefundene Adresse lat : Latitude der Adresse lon : Longitude der Adresse Zus\u00e4tzliche Wildcards {ADDRESS} : gefundene Adresse {LAT} : Latitude der Adresse {LON} : Longitude der Adresse","title":"Geocoding"},{"location":"modul/geocoding.html#geocoding","text":"","title":"Geocoding"},{"location":"modul/geocoding.html#beschreibung","text":"Mit diesem Modul k\u00f6nnen einem Paket die Koordinaten eines Ortes oder einer Adresse angef\u00fcgt werden.","title":"Beschreibung"},{"location":"modul/geocoding.html#unterstutzte-alarmtypen","text":"Pocsag","title":"Unterst\u00fctzte Alarmtypen"},{"location":"modul/geocoding.html#resource","text":"geocoding","title":"Resource"},{"location":"modul/geocoding.html#konfiguration","text":"Feld Beschreibung Default apiProvider Der Provider f\u00fcr das Geocoding apiToken Der Api-Token fuer die Geocoding-Api geoRegex Regex Capture-Group zum Herausfiltern der Adresse","title":"Konfiguration"},{"location":"modul/geocoding.html#verfugbare-geocoding-provider","text":"Name Einstellungswert Mapbox mapbox Google Maps google Beispiel: - type: module name: Geocoding Module res: geocoding config: apiProvider: \"{{ Provider f\u00fcr Geocoding }}\" apiToken: \"{{ API-Key f\u00fcr Provider }}\" regex: \"((?:[^ ]*,)*?)\"","title":"Verf\u00fcgbare Geocoding Provider"},{"location":"modul/geocoding.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"modul/geocoding.html#externe-abhangigkeiten","text":"geocoder","title":"Externe Abh\u00e4ngigkeiten"},{"location":"modul/geocoding.html#paket-modifikationen","text":"address : gefundene Adresse lat : Latitude der Adresse lon : Longitude der Adresse","title":"Paket Modifikationen"},{"location":"modul/geocoding.html#zusatzliche-wildcards","text":"{ADDRESS} : gefundene Adresse {LAT} : Latitude der Adresse {LON} : Longitude der Adresse","title":"Zus\u00e4tzliche Wildcards"},{"location":"modul/mode_filter.html","text":"Mode Filter Beschreibung Mit diesem Modul ist es m\u00f6glich, die Pakete auf bestimmte Modes (FMS, POCSAG, ZVEI) zu Filtern. Je nach Konfiguration werden Pakete eines bestimmten Modes im aktuellen Router weitergeleitet oder verworfen. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Msg Resource filter.modeFilter Konfiguration Feld Beschreibung Default allowed Liste der erlaubten Paket Typen fms zvei pocsag msg Beispiel: - type: module res: filter.modeFilter config: allowed: - fms - pocsag Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten keine Paket Modifikationen keine Zus\u00e4tzliche Wildcards keine","title":"Mode Filter"},{"location":"modul/mode_filter.html#mode-filter","text":"","title":"Mode Filter"},{"location":"modul/mode_filter.html#beschreibung","text":"Mit diesem Modul ist es m\u00f6glich, die Pakete auf bestimmte Modes (FMS, POCSAG, ZVEI) zu Filtern. Je nach Konfiguration werden Pakete eines bestimmten Modes im aktuellen Router weitergeleitet oder verworfen.","title":"Beschreibung"},{"location":"modul/mode_filter.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei Msg","title":"Unterst\u00fctze Alarmtypen"},{"location":"modul/mode_filter.html#resource","text":"filter.modeFilter","title":"Resource"},{"location":"modul/mode_filter.html#konfiguration","text":"Feld Beschreibung Default allowed Liste der erlaubten Paket Typen fms zvei pocsag msg Beispiel: - type: module res: filter.modeFilter config: allowed: - fms - pocsag","title":"Konfiguration"},{"location":"modul/mode_filter.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"modul/mode_filter.html#externe-abhangigkeiten","text":"keine","title":"Externe Abh\u00e4ngigkeiten"},{"location":"modul/mode_filter.html#paket-modifikationen","text":"keine","title":"Paket Modifikationen"},{"location":"modul/mode_filter.html#zusatzliche-wildcards","text":"keine","title":"Zus\u00e4tzliche Wildcards"},{"location":"modul/regex_filter.html","text":"Regex Filter Beschreibung Mit diesem Modul ist es m\u00f6glich, komplexe Filter basierend auf Regul\u00e4ren Ausdr\u00fccken (Regex) anzulegen. F\u00fcr einen Filter k\u00f6nnen beliebig viele Checks angelegt werden, welche Felder eines BOSWatch Pakets mittels Regex pr\u00fcfen. Folgendes gilt: Die Filter werden nacheinander abgearbeitet Innerhalb des Filters werden die Checks nacheinander abgearbeitet Sobald ein einzelner Check fehlschl\u00e4gt ist der ganze Filter fehlgeschlagen Sobald ein Filter mit all seinen Checks besteht, wird mit der Ausf\u00fchrung des Routers fortgefahren Sollten alle Filter fehlschlagen wird die Ausf\u00fchrung des Routers beendet Vereinfacht kann man sagen, dass einzelnen Router ODER-verkn\u00fcpft und die jeweiligen Checks UND-verkn\u00fcpft sind. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Msg Resource filter.regexFilter Konfiguration Feld Beschreibung Default name Beliebiger Name des Filters checks Liste der einzelnen Checks innerhalb des Filters checks: Feld Beschreibung Default field Name des Feldes innerhalb des BOSWatch Pakets welches untersucht werden soll regex Regul\u00e4rer Ausdruck (Bei Sonderzeichen \" \" verwenden) Beispiel: - type: module res: filter.regexFilter config: - name: \"Zvei filter\" checks: - field: tone regex: \"65[0-9]{3}\" # all zvei with starting 65 - name: \"FMS Stat 3\" checks: - field: mode regex: \"fms\" # check if mode is fms - field: status regex: \"3\" # check if status is 3 Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten keine Paket Modifikationen keine Zus\u00e4tzliche Wildcards keine","title":"Regex Filter"},{"location":"modul/regex_filter.html#regex-filter","text":"","title":"Regex Filter"},{"location":"modul/regex_filter.html#beschreibung","text":"Mit diesem Modul ist es m\u00f6glich, komplexe Filter basierend auf Regul\u00e4ren Ausdr\u00fccken (Regex) anzulegen. F\u00fcr einen Filter k\u00f6nnen beliebig viele Checks angelegt werden, welche Felder eines BOSWatch Pakets mittels Regex pr\u00fcfen. Folgendes gilt: Die Filter werden nacheinander abgearbeitet Innerhalb des Filters werden die Checks nacheinander abgearbeitet Sobald ein einzelner Check fehlschl\u00e4gt ist der ganze Filter fehlgeschlagen Sobald ein Filter mit all seinen Checks besteht, wird mit der Ausf\u00fchrung des Routers fortgefahren Sollten alle Filter fehlschlagen wird die Ausf\u00fchrung des Routers beendet Vereinfacht kann man sagen, dass einzelnen Router ODER-verkn\u00fcpft und die jeweiligen Checks UND-verkn\u00fcpft sind.","title":"Beschreibung"},{"location":"modul/regex_filter.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei Msg","title":"Unterst\u00fctze Alarmtypen"},{"location":"modul/regex_filter.html#resource","text":"filter.regexFilter","title":"Resource"},{"location":"modul/regex_filter.html#konfiguration","text":"Feld Beschreibung Default name Beliebiger Name des Filters checks Liste der einzelnen Checks innerhalb des Filters","title":"Konfiguration"},{"location":"modul/regex_filter.html#checks","text":"Feld Beschreibung Default field Name des Feldes innerhalb des BOSWatch Pakets welches untersucht werden soll regex Regul\u00e4rer Ausdruck (Bei Sonderzeichen \" \" verwenden) Beispiel: - type: module res: filter.regexFilter config: - name: \"Zvei filter\" checks: - field: tone regex: \"65[0-9]{3}\" # all zvei with starting 65 - name: \"FMS Stat 3\" checks: - field: mode regex: \"fms\" # check if mode is fms - field: status regex: \"3\" # check if status is 3","title":"checks:"},{"location":"modul/regex_filter.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"modul/regex_filter.html#externe-abhangigkeiten","text":"keine","title":"Externe Abh\u00e4ngigkeiten"},{"location":"modul/regex_filter.html#paket-modifikationen","text":"keine","title":"Paket Modifikationen"},{"location":"modul/regex_filter.html#zusatzliche-wildcards","text":"keine","title":"Zus\u00e4tzliche Wildcards"},{"location":"plugin/divera.html","text":"Divera 24/7 Beschreibung Mit diesem Plugin ist es m\u00f6glich, HTTPS-Anfragen f\u00fcr Alarmierungen an Divera 24/7 zu senden. Wildcards in den Urls werden automatisch ersetzt. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Msg Resource divera Konfiguration Feld Beschreibung Default accesskey Web-API-Schl\u00fcssel von Divera24/7 priority Sonderrechte false title Titel der Meldung s. Beispiel message Nachrichteninhalt s. Beispiel ric Auszul\u00f6sende RIC in Divera; Gruppen->Alarmierungs-RIC vehicle Fahrzeug-Alarmierungs-RIC Beispiel: - type: plugin name: Divera Plugin res: divera config: accesskey: API-Key pocsag: priority: false title: \"{RIC}({SRIC})\\n{MSG}\" message: \"{MSG}\" # RIC ist in Divera definiert ric: Probealarm fms: priority: false title: \"{FMS}\" message: \"{FMS}\" vehicle: MTF zvei: ric: Probealarm title: \"{TONE}\" message: \"{TONE}\" priority: false msg: priority: false title: \"{MSG}\" message: \"{MSG}\" # RIC ist in Divera definiert ric: Probealarm Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten asyncio aiohttp urllib","title":"Divera"},{"location":"plugin/divera.html#divera-247","text":"","title":"Divera 24/7"},{"location":"plugin/divera.html#beschreibung","text":"Mit diesem Plugin ist es m\u00f6glich, HTTPS-Anfragen f\u00fcr Alarmierungen an Divera 24/7 zu senden. Wildcards in den Urls werden automatisch ersetzt.","title":"Beschreibung"},{"location":"plugin/divera.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei Msg","title":"Unterst\u00fctze Alarmtypen"},{"location":"plugin/divera.html#resource","text":"divera","title":"Resource"},{"location":"plugin/divera.html#konfiguration","text":"Feld Beschreibung Default accesskey Web-API-Schl\u00fcssel von Divera24/7 priority Sonderrechte false title Titel der Meldung s. Beispiel message Nachrichteninhalt s. Beispiel ric Auszul\u00f6sende RIC in Divera; Gruppen->Alarmierungs-RIC vehicle Fahrzeug-Alarmierungs-RIC Beispiel: - type: plugin name: Divera Plugin res: divera config: accesskey: API-Key pocsag: priority: false title: \"{RIC}({SRIC})\\n{MSG}\" message: \"{MSG}\" # RIC ist in Divera definiert ric: Probealarm fms: priority: false title: \"{FMS}\" message: \"{FMS}\" vehicle: MTF zvei: ric: Probealarm title: \"{TONE}\" message: \"{TONE}\" priority: false msg: priority: false title: \"{MSG}\" message: \"{MSG}\" # RIC ist in Divera definiert ric: Probealarm","title":"Konfiguration"},{"location":"plugin/divera.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"plugin/divera.html#externe-abhangigkeiten","text":"asyncio aiohttp urllib","title":"Externe Abh\u00e4ngigkeiten"},{"location":"plugin/http.html","text":"Http Beschreibung Mit diesem Plugin ist es moeglich, Http-Anfragen f\u00fcr Alarmierungen zu senden. Wildcards in den Urls werden automatisch ersetzt. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Msg Resource http Konfiguration Feld Beschreibung Default fms Liste mit Urls f\u00fcr Fms-Alarmierung pocsag Liste mit Urls f\u00fcr Pocsag-Alarmierung zvei Liste mit Urls f\u00fcr Zvei-Alarmierung msg Liste mit Urls f\u00fcr Msg-Alarmierung Beispiel: - type: plugin name: HTTP Plugin res: http config: pocsag: - \"http://google.com?q={MSG}\" - \"http://duckduckgo.com?q={MSG}\" fms: - \"http://duckduckgo.com?q={LOC}\" Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten asyncio aiohttp","title":"Http"},{"location":"plugin/http.html#http","text":"","title":"Http"},{"location":"plugin/http.html#beschreibung","text":"Mit diesem Plugin ist es moeglich, Http-Anfragen f\u00fcr Alarmierungen zu senden. Wildcards in den Urls werden automatisch ersetzt.","title":"Beschreibung"},{"location":"plugin/http.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei Msg","title":"Unterst\u00fctze Alarmtypen"},{"location":"plugin/http.html#resource","text":"http","title":"Resource"},{"location":"plugin/http.html#konfiguration","text":"Feld Beschreibung Default fms Liste mit Urls f\u00fcr Fms-Alarmierung pocsag Liste mit Urls f\u00fcr Pocsag-Alarmierung zvei Liste mit Urls f\u00fcr Zvei-Alarmierung msg Liste mit Urls f\u00fcr Msg-Alarmierung Beispiel: - type: plugin name: HTTP Plugin res: http config: pocsag: - \"http://google.com?q={MSG}\" - \"http://duckduckgo.com?q={MSG}\" fms: - \"http://duckduckgo.com?q={LOC}\"","title":"Konfiguration"},{"location":"plugin/http.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"plugin/http.html#externe-abhangigkeiten","text":"asyncio aiohttp","title":"Externe Abh\u00e4ngigkeiten"},{"location":"plugin/mysql.html","text":"Mysql Beschreibung Mit diesem Plugin ist es moeglich, die Alarmierungen in einer Mysql / Mariadb Datenbank zu speichern. Das Plugin legt die Tabelle \"boswatch\" selbststaendig an, wenn diese nicht vorhanden ist. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Msg Resource mysql Konfiguration Feld Beschreibung Default host IP-Adresse bzw. URL des Hosts user Username password Passwort database Name der Datenbank Beispiel: - type: plugin name: mysql res: mysql config: host: HOST user: USERNAME password: PASSWORD database: DATABASE Modul Abh\u00e4ngigkeiten keine Externe Abh\u00e4ngigkeiten mysql-connector-python","title":"MySQL"},{"location":"plugin/mysql.html#mysql","text":"","title":"Mysql"},{"location":"plugin/mysql.html#beschreibung","text":"Mit diesem Plugin ist es moeglich, die Alarmierungen in einer Mysql / Mariadb Datenbank zu speichern. Das Plugin legt die Tabelle \"boswatch\" selbststaendig an, wenn diese nicht vorhanden ist.","title":"Beschreibung"},{"location":"plugin/mysql.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei Msg","title":"Unterst\u00fctze Alarmtypen"},{"location":"plugin/mysql.html#resource","text":"mysql","title":"Resource"},{"location":"plugin/mysql.html#konfiguration","text":"Feld Beschreibung Default host IP-Adresse bzw. URL des Hosts user Username password Passwort database Name der Datenbank Beispiel: - type: plugin name: mysql res: mysql config: host: HOST user: USERNAME password: PASSWORD database: DATABASE","title":"Konfiguration"},{"location":"plugin/mysql.html#modul-abhangigkeiten","text":"keine","title":"Modul Abh\u00e4ngigkeiten"},{"location":"plugin/mysql.html#externe-abhangigkeiten","text":"mysql-connector-python","title":"Externe Abh\u00e4ngigkeiten"},{"location":"plugin/telegram.html","text":"Telegram Beschreibung Mit diesem Plugin ist es moeglich, Telegram-Nachrichten f\u00fcr POCSAG-Alarmierungen zu senden. Au\u00dferdem werden Locations versendet, wenn die Felder lat und lon im Paket definiert sind. (beispielsweise durch das Geocoding Modul) Die abarbeitung der Alarmierungen erfolgt per Queue nach den Limits der Telegram API, damit keine Nachrichten verloren gehen, diese Funktion kann mit dem queue Parameter deaktiviert werden. Unterst\u00fctze Alarmtypen Fms Pocsag Zvei Msg Resource telegram Konfiguration Feld Beschreibung Default botToken Der Api-Key des Telegram-Bots chatIds Liste mit Chat-Ids der Empf\u00e4ngers / der Emf\u00e4nger-Gruppen message_fms Format der Nachricht f\u00fcr FMS {FMS} message_pocsag Format der Nachricht f\u00fcr Pocsag {RIC}({SRIC})\\n{MSG} message_zvei Format der Nachricht f\u00fcr ZVEI {TONE} message_msg Format der Nachricht f\u00fcr MSG queue Aktivieren/Deaktivieren der MessageQueue true Beispiel: - type: plugin name: Telegram Plugin res: telegram config: message_pocsag: \"{RIC}({SRIC})\\n{MSG}\" botToken: \"BOT_TOKEN\" chatIds: - \"CHAT_ID\" Modul Abh\u00e4ngigkeiten Aus dem Modul Geocoding (optional/nur POCSAG): lat lon Externe Abh\u00e4ngigkeiten python-telegram-bot","title":"Telegram"},{"location":"plugin/telegram.html#telegram","text":"","title":"Telegram"},{"location":"plugin/telegram.html#beschreibung","text":"Mit diesem Plugin ist es moeglich, Telegram-Nachrichten f\u00fcr POCSAG-Alarmierungen zu senden. Au\u00dferdem werden Locations versendet, wenn die Felder lat und lon im Paket definiert sind. (beispielsweise durch das Geocoding Modul) Die abarbeitung der Alarmierungen erfolgt per Queue nach den Limits der Telegram API, damit keine Nachrichten verloren gehen, diese Funktion kann mit dem queue Parameter deaktiviert werden.","title":"Beschreibung"},{"location":"plugin/telegram.html#unterstutze-alarmtypen","text":"Fms Pocsag Zvei Msg","title":"Unterst\u00fctze Alarmtypen"},{"location":"plugin/telegram.html#resource","text":"telegram","title":"Resource"},{"location":"plugin/telegram.html#konfiguration","text":"Feld Beschreibung Default botToken Der Api-Key des Telegram-Bots chatIds Liste mit Chat-Ids der Empf\u00e4ngers / der Emf\u00e4nger-Gruppen message_fms Format der Nachricht f\u00fcr FMS {FMS} message_pocsag Format der Nachricht f\u00fcr Pocsag {RIC}({SRIC})\\n{MSG} message_zvei Format der Nachricht f\u00fcr ZVEI {TONE} message_msg Format der Nachricht f\u00fcr MSG queue Aktivieren/Deaktivieren der MessageQueue true Beispiel: - type: plugin name: Telegram Plugin res: telegram config: message_pocsag: \"{RIC}({SRIC})\\n{MSG}\" botToken: \"BOT_TOKEN\" chatIds: - \"CHAT_ID\"","title":"Konfiguration"},{"location":"plugin/telegram.html#modul-abhangigkeiten","text":"Aus dem Modul Geocoding (optional/nur POCSAG): lat lon","title":"Modul Abh\u00e4ngigkeiten"},{"location":"plugin/telegram.html#externe-abhangigkeiten","text":"python-telegram-bot","title":"Externe Abh\u00e4ngigkeiten"}]}